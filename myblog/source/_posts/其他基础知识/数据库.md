---
title: 数据库
date: 2021-06-13 20:05:03
tags:
- 数据库
- 面试
categories:
- 数据库
---

# 索引
索引是对数据库表中一列或多列的值进行排序的数据结构，他们的底层使用的都是BTree，使用索引可以快速定位到特定的信息，提高查找效率。
分类如下

## 普通索引
最基本的索引之一，没有唯一性的限制。
创建方式：` create index indexname on tablename(line1,line2,...) `

## 唯一索引
在普通索引的基础上，增加了唯一性的限制，即索引列中不可能出出现相同的值。
创建方式：` create uniqe index indexname on tablename(line1,line2,...) `

## 主键索引
在主键上增加索引，在MySQL中默认会为主键增加索引，如果没有指定主键，则会将默认生成一个以行号为标志的索引。
主键索引也是一种聚集索引。

## 聚集索引
建立索引后数据的物理关系和索引的逻辑关系是相同的。

# 数据库事物
指单个逻辑单元执行一系列操作，这些操作要么全部执行，要么全部不执行，它确保每次处理成为一个整体。

## ACID原则
1. 原子性（Atomicity）
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

2. 一致性（Consistency）
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3. 隔离性（Isolation）
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。
不同的隔离级别：
Read Uncommitted（读取未提交内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

4. 持久性（Durability）
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

## 事务隔离级别
1. 读未提交内容：在其他事务执行一系列操作并且还没有提交时，本事物已经获取了这一系列操作的结果，并且会在后续的读取中读取到这些内容，这种操作很明显的暴露出来了一个缺点，由于事物是支持回滚的，如果另一个事务执行操作后因为某种原因回滚到执行前的状态，但是本事物并不知道另一个事务已经回滚，则后续读出来的数据可能就是“脏数据”，因此出现了脏读的问题。
2. 读提交内容：为了解决上述问题，本隔离级别不允许事务获取其他事务未提交的内容，使得如果其他事务出现了回滚操作时结果是一样的，这也是许多数据库使用的隔离级别，但如果本事务在执行的时候其他事务提交了内容，那么本次事务在另一事务提交前后读取到的内容是不一样的，这种现象称之为不可重复读取。
3. 可重复读：为了解决不可重复读的问题，采取MVCC版本控制机制进行版本控制，当一个事务不进行更新等可能修改数据的操作时，事务读取的数据始终停留在原来的版本，无论其他事务是否提交了修改数据指令，本事务两次读取的内容都控制在同一个版本中，因此重复读取到的结果是一样的。当本次事务出现了数据更新时，数据库将更新操作应用于当前表格的最新版本上，同时将版本设置为修改数据后的版本，这样也保证了并发事务间的同步。但是当本事务两次读取行为间增加一个更新操作，而更新操作执行前另一个事务提交了一个插入操作，这个更新不会应用到插入和行中，就好像产生了幻觉一样，则称这种现象为“幻读”。
4. 串行化读取：为了解决幻读问题，通过使用锁机制对数据进行访问控制，具体使用的锁为行锁和范围锁，当某一事务执行了读取操作后，会将读取的部分“锁定”，即锁住对应的行（行锁）不允许更改，也锁定读取的范围（范围锁），不允许插入操作，使得其他事务无法对读取到的部分进行任何操作从而解决这一问题。


# 存储引擎
对于MySQL来说，最常用的两个引擎分别是MAISAM和INNODB。
## INNODB
事务型存储引擎，有行级锁和外键约束。
提供数据库ACID事务支持，实现了SQL标准四种隔离级别，不保存表的行数，统计行数时要访问整个表，锁的粒度小，写操作不会锁定全表。
使用场景：适用于经常更新的表，适合处理多重并发请求。
特点：B+树数据存储索引值，因此是聚集索引。

## MYISAM
MySQL的默认引擎，不提供数据库事务，也不提供行级锁和外键，因此在执行写操作时会锁定整个表。
独立于操作系统，可以比较简单的进行数据转移。
特点：查询速度快，表保存了行数，统计行数时不需要访问整个表，只需要输出表的行数即可，但是如果加了where条件，一样需要遍历整个表。索引的B+树数据域存储实际数据地址，因此是非聚集索引。

## 二者区别
1. 事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。

2. 性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。

3. 行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。

4. 索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。
MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。

5. 服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。
InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。

6. 锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

# 三大范式
## 第一范式
列不可再分

## 第二范式
不存在非主属性对码的部分依赖

## 第三范式
不存在非主属性对码的部份依赖和传递依赖

## BCNF
不存在主属性对码的部份依赖和传递依赖